Project "Moderation Orchestrator" {
  database_type: "PostgreSQL"
}

Enum status { 
  pending 
  completed
  failed
  timed_out 
}

Enum verdict {
  allow
  block
  review
  error
}

Table moderation_jobs {
  correlating_id uuid [pk, note: "Correlation id carried in inbound/outbound events"]
  content_id text [note: "Opaque content identifier from ContentService"]
  submitter_id text [note: "Actor who created the content; may be a user id"]
  status status [not null, default: 'pending']
  created_at timestamptz [not null, default: `now()`]
  updated_at timestamptz [not null, default: `now()`]

  Note: "Entry point for every moderation job; tracks lifecycle and ownership."
}

Table text_data {
  correlating_id uuid [pk, ref: > moderation_jobs.correlating_id, note: "ON DELETE CASCADE"]
  text_excerpt text [note: "Stored text or excerpt for moderation"]
  created_at timestamptz [not null, default: `now()`]
}

Table image_data {
  correlating_id uuid [pk, ref: > moderation_jobs.correlating_id, note: "ON DELETE CASCADE"]
  image_uri text [not null, note: "Reference to image object (e.g., S3/Seaweed key)"]
  created_at timestamptz [not null, default: `now()`]
}

Table job_tasks {
  id bigserial [pk]
  correlating_id uuid [not null, ref: > moderation_jobs.correlating_id, note: "ON DELETE CASCADE"]
  event_name varchar(128) [not null, note: "Logical event identifier used for fan-out and correlation"]
  status status [not null, default: 'pending']
  payload jsonb [note: "Raw event payload from the service (aligns to envelope payload)"]
  started_at timestamptz [default: `now()`]
  completed_at timestamptz

  Note: "One row per configured service (moderator) for a job. Insert rows at job start; update as events arrive."

  Indexes {
    (correlating_id, event_name) [name: "uq_job_tasks_job_event", unique]
    (correlating_id, status)
  }
}

Table moderation_decisions {
  correlating_id uuid [pk, ref: > moderation_jobs.correlating_id, note: "ON DELETE CASCADE"]
  final_verdict verdict [not null]
  timed_out bool [not null, default: false, note: "True if any task exceeded its SLA"]
  decided_at timestamptz [not null, default: `now()`]

  Note: "Aggregated decision persisted for audits and replay."
}
